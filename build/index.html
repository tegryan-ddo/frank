<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frank - Claude Code Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* Styled scrollbars - matches VS Code dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4c4c4c;
        }

        ::-webkit-scrollbar-corner {
            background: #1e1e1e;
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: #3c3c3c #1e1e1e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #252526;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            border-bottom: 1px solid #3c3c3c;
        }

        .header h1 {
            font-size: 14px;
            font-weight: 500;
            color: #cccccc;
        }

        .profile-badge {
            display: none;
            padding: 3px 10px;
            background: #0e639c;
            color: #ffffff;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 500;
            font-family: 'Consolas', 'Monaco', monospace;
            letter-spacing: 0.3px;
        }

        .profile-badge.visible {
            display: inline-block;
        }

        .user-badge {
            display: none;
            padding: 3px 10px;
            background: #2d2d2d;
            color: #9d9d9d;
            border: 1px solid #3c3c3c;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
        }

        .user-badge.visible {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .user-badge .user-icon {
            font-size: 12px;
        }

        .users-online {
            display: none;
            padding: 3px 10px;
            background: #1e3a1e;
            border: 1px solid #3c3c3c;
            border-radius: 10px;
            font-size: 11px;
            color: #6a9955;
            cursor: pointer;
            transition: all 0.2s;
        }

        .users-online.visible {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .users-online:hover {
            background: #2d5a2d;
        }

        .users-online .users-count {
            font-weight: 600;
        }

        .users-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 8px 0;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .users-tooltip.visible {
            display: block;
        }

        .users-tooltip-item {
            padding: 6px 12px;
            font-size: 11px;
            color: #d4d4d4;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .users-tooltip-item .user-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #6a9955;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            margin-left: auto;
        }

        .tabs {
            display: flex;
            gap: 4px;
        }

        .tab {
            padding: 6px 12px;
            background: #2d2d2d;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            color: #9d9d9d;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3c3c3c;
            color: #ffffff;
        }

        .tab.active {
            background: #0e639c;
            border-color: #0e639c;
            color: #ffffff;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .terminals-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }

        .pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .pane.hidden {
            display: none;
        }

        .pane-header {
            background: #2d2d2d;
            padding: 6px 12px;
            font-size: 12px;
            color: #9d9d9d;
            border-bottom: 1px solid #3c3c3c;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pane-header .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6a9955;
        }

        .divider-h {
            height: 4px;
            background: #3c3c3c;
            cursor: row-resize;
            flex-shrink: 0;
        }

        .divider-h:hover {
            background: #0e639c;
        }

        iframe {
            flex: 1;
            width: 100%;
            height: 100%;
            border: none;
            background: #1e1e1e;
            overflow: hidden;
            scrollbar-width: none;          /* Firefox */
        }
        iframe::-webkit-scrollbar {
            display: none;                  /* Chrome/Safari/Edge */
        }

        /* Layout modes */
        .terminals-wrapper.split .pane { flex: 1; }
        .terminals-wrapper.claude-only .pane.bash { display: none; }
        .terminals-wrapper.claude-only .divider-h { display: none; }
        .terminals-wrapper.bash-only .pane.claude { display: none; }
        .terminals-wrapper.bash-only .divider-h { display: none; }

        /* Context Panel - always visible */
        .context-panel {
            width: 280px;
            background: #252526;
            border-left: 1px solid #3c3c3c;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .context-panel-header {
            background: #2d2d2d;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            color: #cccccc;
            border-bottom: 1px solid #3c3c3c;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .context-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            scrollbar-width: thin;
            scrollbar-color: #3c3c3c #252526;
        }

        .context-panel-content::-webkit-scrollbar {
            display: block;
            width: 6px;
        }

        .context-panel-content::-webkit-scrollbar-track {
            background: #252526;
        }

        .context-panel-content::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 3px;
        }

        .context-panel-content::-webkit-scrollbar-thumb:hover {
            background: #4c4c4c;
        }

        .context-section {
            margin-bottom: 16px;
        }

        .context-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #9d9d9d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .context-usage-bar {
            height: 20px;
            background: #1e1e1e;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .context-usage-fill {
            height: 100%;
            background: linear-gradient(90deg, #6a9955, #4ec9b0);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            padding-left: 8px;
        }

        .context-usage-fill.warning {
            background: linear-gradient(90deg, #dcdcaa, #ce9178);
        }

        .context-usage-fill.error {
            background: linear-gradient(90deg, #f44747, #d16969);
        }

        .context-usage-text {
            font-size: 10px;
            color: #1e1e1e;
            font-weight: 600;
        }

        .context-usage-details {
            font-size: 11px;
            color: #9d9d9d;
            text-align: right;
        }

        .context-file-list {
            list-style: none;
        }

        .context-file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            margin-bottom: 2px;
            background: #1e1e1e;
            border-radius: 4px;
            font-size: 11px;
        }

        .context-file-item:hover {
            background: #2d2d2d;
        }

        .context-file-name {
            color: #4ec9b0;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .context-tool-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 8px;
            margin-bottom: 2px;
            font-size: 11px;
        }

        .context-tool-name {
            color: #dcdcaa;
        }

        .context-tool-count {
            color: #9d9d9d;
            background: #3c3c3c;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        .context-empty {
            color: #6d6d6d;
            font-size: 11px;
            font-style: italic;
            text-align: center;
            padding: 12px;
        }

        .context-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 11px;
            border-bottom: 1px solid #3c3c3c;
        }

        .context-stat-row:last-child {
            border-bottom: none;
        }

        .context-stat-label {
            color: #9d9d9d;
        }

        .context-stat-value {
            color: #cccccc;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .context-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6a9955;
            display: inline-block;
            margin-right: 6px;
        }

        .context-status-indicator.warning {
            background: #dcdcaa;
        }

        .context-status-indicator.error {
            background: #f44747;
        }

        .context-model-badge {
            background: #0e639c;
            color: #ffffff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
        }

        .context-panel-header-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Feedback Section */
        .feedback-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #3c3c3c;
        }

        .feedback-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .feedback-btn {
            flex: 1;
            padding: 10px 16px;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .feedback-btn.positive {
            background: #1e3a1e;
            color: #6a9955;
        }

        .feedback-btn.positive:hover {
            background: #2d5a2d;
            border-color: #6a9955;
        }

        .feedback-btn.negative {
            background: #3a1e1e;
            color: #f44747;
        }

        .feedback-btn.negative:hover {
            background: #5a2d2d;
            border-color: #f44747;
        }

        .feedback-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .feedback-sent {
            text-align: center;
            padding: 12px;
            color: #6a9955;
            font-size: 12px;
        }

        .dashboard-link {
            display: block;
            margin-top: 16px;
            padding: 10px;
            background: #2d2d2d;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            color: #4ec9b0;
            text-decoration: none;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .dashboard-link:hover {
            background: #3c3c3c;
            border-color: #4ec9b0;
        }

        /* Floating Prompt Bubble */
        .prompt-fab {
            position: fixed;
            bottom: 16px;
            right: 316px; /* 280px context panel + 16px margin + 20px left */
            width: 36px;
            height: 36px;
            background: #0e639c;
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 22px;
            font-weight: 300;
            cursor: pointer;
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            transition: background 0.15s, transform 0.15s;
            line-height: 1;
        }

        .prompt-fab:hover {
            background: #1177bb;
            transform: scale(1.08);
        }

        .prompt-bubble {
            position: fixed;
            bottom: 62px;
            right: 316px; /* 280px context panel + 16px margin + 20px left */
            width: 400px;
            max-height: 320px;
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 10px;
            z-index: 501;
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .prompt-bubble.open {
            display: flex;
        }

        .prompt-bubble textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 10px 12px;
            resize: none;
            outline: none;
            min-height: 160px;
        }

        .prompt-bubble textarea::placeholder {
            color: #555;
        }

        .prompt-bubble-bar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            padding: 6px 10px;
            border-top: 1px solid #333;
            background: #252526;
        }

        .prompt-bubble-bar label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #9d9d9d;
            cursor: pointer;
            white-space: nowrap;
        }

        .prompt-bubble-bar label input[type="checkbox"] {
            accent-color: #0e639c;
            cursor: pointer;
        }

        .prompt-bubble-send {
            background: #0e639c;
            border: none;
            color: #fff;
            font-size: 11px;
            padding: 5px 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .prompt-bubble-send:hover {
            background: #1177bb;
        }

        .prompt-bubble-send:disabled {
            opacity: 0.5;
            cursor: default;
        }

        .prompt-bubble-send.stop {
            background: #a83232;
        }

        .prompt-bubble-send.stop:hover {
            background: #c43e3e;
        }

        .prompt-timer-select {
            background: #2d2d2d;
            border: 1px solid #3c3c3c;
            color: #d4d4d4;
            font-size: 11px;
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            outline: none;
        }

        .prompt-timer-select:focus {
            border-color: #0e639c;
        }

        .prompt-fab.timer-active::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            background: #6a9955;
            border-radius: 50%;
            border: 1.5px solid #1e1e1e;
            animation: timer-pulse 1.5s ease-in-out infinite;
        }

        @keyframes timer-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .prompt-copied-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #6a9955;
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            pointer-events: none;
        }

        .prompt-copied-toast.visible {
            opacity: 1;
        }

        /* Update Available Indicator */
        .update-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            padding: 4px 12px;
            background: #3d3d00;
            border: 1px solid #dcdcaa;
            border-radius: 4px;
            font-size: 11px;
            color: #dcdcaa;
        }

        .update-indicator.visible {
            display: flex;
        }

        .update-indicator .update-icon {
            font-size: 14px;
        }

        .update-indicator .update-text {
            font-weight: 500;
        }

        .update-indicator .update-version {
            color: #9d9d9d;
            font-family: 'Consolas', monospace;
        }

        .restart-btn {
            padding: 4px 10px;
            background: #0e639c;
            border: none;
            border-radius: 3px;
            color: #ffffff;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .restart-btn:hover {
            background: #1177bb;
        }

        .restart-btn:disabled {
            background: #3c3c3c;
            cursor: not-allowed;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        .loading-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .loading-content {
            position: relative;
            z-index: 1;
            text-align: center;
            max-width: 600px;
            padding: 0 24px;
        }

        .loading-title {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, #4fc3f7, #7c4dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .loading-subtitle {
            font-size: 14px;
            color: #808080;
            margin-bottom: 48px;
        }

        .loading-trivia {
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 48px;
        }

        .loading-trivia-text {
            font-size: 15px;
            color: #b0b0b0;
            line-height: 1.6;
            font-style: italic;
            transition: opacity 0.4s ease;
        }

        .loading-progress {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 320px;
            margin: 0 auto;
        }

        .loading-step {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #555;
            transition: color 0.3s ease;
        }

        .loading-step.active {
            color: #b0b0b0;
        }

        .loading-step.done {
            color: #6a9955;
        }

        .loading-step-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #3c3c3c;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .loading-step.active .loading-step-icon {
            border-color: #4fc3f7;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.3);
        }

        .loading-step.active .loading-step-icon::after {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4fc3f7;
            animation: pulse-dot 1.2s ease-in-out infinite;
        }

        .loading-step.done .loading-step-icon {
            border-color: #6a9955;
            background: #6a9955;
        }

        .loading-step.done .loading-step-icon::after {
            content: '\2713';
            font-size: 10px;
            color: #fff;
            line-height: 1;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(0.6); }
        }

        /* Mobile Tab Bar - hidden by default */
        .mobile-tab-bar {
            display: none;
        }

        /* Mobile Responsive Layout */
        @media (max-width: 768px) {
            .tabs {
                display: none !important;
            }

            .context-panel {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 48px;
                width: 100%;
                z-index: 100;
                border-left: none;
            }

            .context-panel.mobile-visible {
                display: flex;
            }

            .main-container {
                position: relative;
            }

            .terminals-wrapper {
                position: relative;
            }

            .terminals-wrapper .pane {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
            }

            .terminals-wrapper .pane.mobile-active {
                display: flex;
            }

            .terminals-wrapper .divider-h {
                display: none !important;
            }

            .mobile-tab-bar {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 48px;
                background: #252526;
                border-top: 1px solid #3c3c3c;
                z-index: 200;
                padding-bottom: env(safe-area-inset-bottom, 0px);
            }

            .mobile-tab-bar button {
                flex: 1;
                background: transparent;
                border: none;
                color: #6d6d6d;
                font-size: 10px;
                cursor: pointer;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 2px;
                transition: color 0.15s;
                padding: 4px 0;
            }

            .mobile-tab-bar button .tab-icon {
                font-size: 18px;
                line-height: 1;
            }

            .mobile-tab-bar button:hover {
                color: #cccccc;
            }

            .mobile-tab-bar button.active {
                color: #4fc3f7;
            }

            body {
                padding-bottom: 48px;
            }

            .prompt-drawer-trigger {
                bottom: 60px;
            }

            .prompt-drawer {
                height: 60vh;
                bottom: 0;
            }

            .prompt-fab {
                right: 16px;
                bottom: 60px; /* Above mobile tab bar */
            }

            .prompt-bubble {
                right: 16px;
                bottom: 106px; /* Above FAB on mobile */
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <canvas class="loading-canvas" id="loading-canvas"></canvas>
        <div class="loading-content">
            <div class="loading-title">Frank</div>
            <div class="loading-subtitle">Preparing your environment</div>
            <div class="loading-trivia">
                <div class="loading-trivia-text" id="trivia-text"></div>
            </div>
            <div class="loading-progress">
                <div class="loading-step active" id="step-workspace">
                    <span class="loading-step-icon"></span>
                    <span>Setting up workspace...</span>
                </div>
                <div class="loading-step" id="step-plugins">
                    <span class="loading-step-icon"></span>
                    <span>Installing plugins...</span>
                </div>
                <div class="loading-step" id="step-terminals">
                    <span class="loading-step-icon"></span>
                    <span>Starting terminals...</span>
                </div>
                <div class="loading-step" id="step-ready">
                    <span class="loading-step-icon"></span>
                    <span>Almost ready...</span>
                </div>
            </div>
        </div>
    </div>

    <div class="header">
        <h1>Frank</h1>
        <span class="profile-badge" id="profile-badge"></span>
        <div class="tabs">
            <button class="tab active" data-view="split">Split View</button>
            <button class="tab" data-view="claude-only">Claude Only</button>
            <button class="tab" data-view="bash-only">Bash Only</button>
        </div>
        <div class="update-indicator" id="update-indicator">
            <span class="update-icon">&#x21bb;</span>
            <span class="update-text">Update Available</span>
            <span class="update-version" id="update-version"></span>
            <button class="restart-btn" id="restart-btn" title="Stop and restart this profile to apply the update">Restart</button>
        </div>
        <div class="header-right">
            <span class="user-badge" id="user-badge">
                <span class="user-icon">&#x1F464;</span>
                <span id="user-name"></span>
            </span>
            <span class="users-online" id="users-online" title="Active users">
                <span>&#x1F465;</span>
                <span class="users-count" id="users-count">0</span>
                <span>online</span>
            </span>
            <div class="users-tooltip" id="users-tooltip"></div>
        </div>
    </div>

    <div class="main-container">
        <!-- Terminals (stacked vertically) -->
        <div class="terminals-wrapper split" id="terminals-wrapper">
            <div class="pane claude">
                <div class="pane-header">
                    <span class="dot"></span>
                    Claude Code
                </div>
                <iframe id="claude-frame" scrolling="no"></iframe>
            </div>

            <div class="divider-h" id="divider"></div>

            <div class="pane bash">
                <div class="pane-header">
                    <span class="dot"></span>
                    Bash Terminal
                </div>
                <iframe id="bash-frame" scrolling="no"></iframe>
            </div>
        </div>

        <!-- Context Panel (always visible) -->
        <div class="context-panel" id="context-panel">
            <div class="context-panel-header">
                <div class="context-panel-header-status">
                    <span class="context-status-indicator" id="status-indicator"></span>
                    <span id="status-text">Connected</span>
                    <span class="context-model-badge" id="model-name">Sonnet</span>
                </div>
                <span style="font-size: 11px; color: #808080;">Stats</span>
            </div>
            <div class="context-panel-content">
                <!-- Context Usage Section -->
                <div class="context-section">
                    <div class="context-section-title">Context Window</div>
                    <div class="context-usage-bar">
                        <div class="context-usage-fill" id="context-usage-fill" style="width: 0%">
                            <span class="context-usage-text" id="context-usage-pct">-</span>
                        </div>
                    </div>
                    <div class="context-usage-details" id="context-usage-detail">Waiting for data...</div>
                    <div class="context-info-note" id="context-info-note" style="display: none; margin-top: 8px; padding: 8px; background: #1e1e1e; border-radius: 4px; font-size: 10px; color: #808080;">
                        Session data is stored server-side. Use /context in Claude for live stats.
                    </div>
                </div>

                <!-- Stats Section -->
                <div class="context-section">
                    <div class="context-section-title">Session Stats</div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Input Tokens</span>
                        <span class="context-stat-value" id="ctx-tokens-in">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Output Tokens</span>
                        <span class="context-stat-value" id="ctx-tokens-out">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Cache Read</span>
                        <span class="context-stat-value" id="ctx-cache-read">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Cache Created</span>
                        <span class="context-stat-value" id="ctx-cache-create">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Messages</span>
                        <span class="context-stat-value" id="ctx-messages">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Turns</span>
                        <span class="context-stat-value" id="ctx-turns">0</span>
                    </div>
                    <div class="context-stat-row">
                        <span class="context-stat-label">Total Cost</span>
                        <span class="context-stat-value" id="ctx-cost">$0.00</span>
                    </div>
                </div>

                <!-- Tool Usage Section -->
                <div class="context-section">
                    <div class="context-section-title">Tool Usage</div>
                    <div id="tool-usage-list">
                        <div class="context-empty">No tools used yet</div>
                    </div>
                </div>

                <!-- Files Section -->
                <div class="context-section">
                    <div class="context-section-title">Files in Context</div>
                    <ul class="context-file-list" id="context-file-list">
                        <li class="context-empty">No files detected</li>
                    </ul>
                </div>

                <!-- Feedback Section -->
                <div class="feedback-section" id="feedback-section">
                    <div class="context-section-title">Rate Response</div>
                    <div class="feedback-buttons" id="feedback-buttons">
                        <button class="feedback-btn positive" data-rating="positive">
                            <span>Good</span>
                        </button>
                        <button class="feedback-btn negative" data-rating="negative">
                            <span>Bad</span>
                        </button>
                    </div>
                    <div class="feedback-sent" id="feedback-sent" style="display: none;">
                        Thanks for your feedback!
                    </div>
                </div>

                <!-- Dashboard Link -->
                <a href="/dashboard" class="dashboard-link" id="dashboard-link">
                    View Analytics Dashboard
                </a>
            </div>

        </div>

        <!-- Mobile Tab Bar -->
        <div class="mobile-tab-bar" id="mobile-tab-bar">
            <button class="active" data-view="claude"><span class="tab-icon">&#x1F4AC;</span>Claude</button>
            <button data-view="bash"><span class="tab-icon">&#x1F4BB;</span>Bash</button>
            <button data-view="stats"><span class="tab-icon">&#x1F4CA;</span>Stats</button>
        </div>

        <!-- Toast notification -->
        <div class="prompt-copied-toast" id="prompt-toast"></div>

        <!-- Floating prompt button -->
        <button class="prompt-fab" id="prompt-fab" title="Send prompt to Claude">+</button>

        <!-- Floating prompt bubble -->
        <div class="prompt-bubble" id="prompt-bubble">
            <textarea id="prompt-bubble-text" placeholder="Type a prompt for Claude..." rows="4"></textarea>
            <div class="prompt-bubble-bar">
                <label title="Auto-submit after sending">
                    <input type="checkbox" id="prompt-auto-submit" checked>
                    <span>Auto-submit</span>
                </label>
                <select id="prompt-timer" class="prompt-timer-select" title="Repeat interval">
                    <option value="0">Once</option>
                    <option value="60">1m</option>
                    <option value="300">5m</option>
                    <option value="600">10m</option>
                    <option value="1800">30m</option>
                    <option value="3600">1h</option>
                    <option value="14400">4h</option>
                </select>
                <button class="prompt-bubble-send" id="prompt-bubble-send">Send</button>
            </div>
        </div>
    </div>

    <script>
        // Determine terminal URLs based on access method:
        // - Via ALB (ports 80/443): use path-based routing
        //   - Default: /claude/, /bash/
        //   - Profile: /{profile}/, /{profile}/bash/
        // - Direct access (port 7680): use port-based URLs
        (function() {
            const currentPort = parseInt(window.location.port) || (window.location.protocol === 'https:' ? 443 : 80);
            const claudeFrame = document.getElementById('claude-frame');
            const bashFrame = document.getElementById('bash-frame');

            if (currentPort === 443 || currentPort === 80) {
                // Via ALB - detect path prefix from current URL
                // e.g., /enkai/ -> prefix = 'enkai'
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const pathPrefix = pathParts[0] || '';
                const base = `${window.location.protocol}//${window.location.host}`;

                // Check if this is a profile path (not a static route like /claude or /bash)
                const staticRoutes = ['claude', 'bash', 'status', 'health', 'api', 'dashboard', '_t', '_b'];
                if (pathPrefix && !staticRoutes.includes(pathPrefix)) {
                    // Profile-based routing: use subpaths for terminals to avoid iframe loops
                    // /{profile}/_t/ for Claude terminal, /{profile}/_b/ for Bash terminal
                    claudeFrame.src = `${base}/${pathPrefix}/_t/`;
                    bashFrame.src = `${base}/${pathPrefix}/_b/`;
                } else {
                    // Default service routing
                    claudeFrame.src = `${base}/claude/`;
                    bashFrame.src = `${base}/bash/`;
                }
            } else {
                // Direct access - calculate ports (web=7680, claude=7681, bash=7682)
                const claudePort = currentPort + 1;
                const bashPort = currentPort + 2;
                claudeFrame.src = `http://${window.location.hostname}:${claudePort}/`;
                bashFrame.src = `http://${window.location.hostname}:${bashPort}/`;
            }
            console.log('Claude URL:', claudeFrame.src);
            console.log('Bash URL:', bashFrame.src);

            // Show profile badge
            const profileBadge = document.getElementById('profile-badge');
            const badgeParts = window.location.pathname.split('/').filter(Boolean);
            const badgePrefix = badgeParts[0] || '';
            const badgeStatic = ['claude', 'bash', 'status', 'health', 'api', 'dashboard', '_t', '_b'];
            if (badgePrefix && !badgeStatic.includes(badgePrefix)) {
                profileBadge.textContent = badgePrefix;
                profileBadge.classList.add('visible');
                document.title = `Frank - ${badgePrefix}`;
            }
        })();

        // Storage key for preferences (shared across all instances)
        const STORAGE_KEY = 'frank-layout-prefs';

        // Load saved preferences
        function loadPreferences() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Failed to load preferences:', e);
            }
            return { view: 'split', splitRatio: 50 };
        }

        // Save preferences
        function savePreferences(prefs) {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
            } catch (e) {
                console.warn('Failed to save preferences:', e);
            }
        }

        // Initialize from saved preferences
        const prefs = loadPreferences();

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                const wrapper = document.getElementById('terminals-wrapper');
                wrapper.className = 'terminals-wrapper ' + tab.dataset.view;

                // Save view preference
                prefs.view = tab.dataset.view;
                savePreferences(prefs);
            });
        });

        // Restore saved view mode
        if (prefs.view) {
            const targetTab = document.querySelector(`.tab[data-view="${prefs.view}"]`);
            if (targetTab) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                targetTab.classList.add('active');
                document.getElementById('terminals-wrapper').className = 'terminals-wrapper ' + prefs.view;
            }
        }

        // Resizable divider (horizontal)
        const divider = document.getElementById('divider');
        const wrapper = document.getElementById('terminals-wrapper');
        const claudePane = document.querySelector('.pane.claude');
        const bashPane = document.querySelector('.pane.bash');

        let isResizing = false;

        // Restore saved split ratio
        if (prefs.splitRatio && prefs.splitRatio > 20 && prefs.splitRatio < 80) {
            claudePane.style.flex = prefs.splitRatio;
            bashPane.style.flex = 100 - prefs.splitRatio;
        }

        divider.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const wrapperRect = wrapper.getBoundingClientRect();
            const percentage = ((e.clientY - wrapperRect.top) / wrapperRect.height) * 100;

            if (percentage > 20 && percentage < 80) {
                claudePane.style.flex = percentage;
                bashPane.style.flex = 100 - percentage;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                // Save the split ratio when done resizing
                const claudeFlex = parseFloat(claudePane.style.flex) || 50;
                prefs.splitRatio = claudeFlex;
                savePreferences(prefs);
            }
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        });

        // Status polling
        // Determine status URL based on access method:
        // - Via ALB (ports 80/443): use same origin with /status path (with profile prefix if applicable)
        // - Direct access (port 7680): calculate port+3 for local status server
        const statusPort = parseInt(window.location.port) || (window.location.protocol === 'https:' ? 443 : 80);
        let STATUS_URL;
        if (statusPort === 443 || statusPort === 80) {
            // Via ALB - detect profile prefix and use appropriate path
            const pathParts = window.location.pathname.split('/').filter(Boolean);
            const pathPrefix = pathParts[0] || '';
            const staticRoutes = ['claude', 'bash', 'status', 'health', 'api', 'dashboard'];

            if (pathPrefix && !staticRoutes.includes(pathPrefix)) {
                // Profile-based: /{profile}/status
                STATUS_URL = `${window.location.protocol}//${window.location.host}/${pathPrefix}/status`;
            } else {
                // Default: /status
                STATUS_URL = `${window.location.protocol}//${window.location.host}/status`;
            }
        } else {
            // Direct access - calculate status port (status server now on same port as web)
            STATUS_URL = `http://${window.location.hostname}:${statusPort}/status`;
        }
        console.log('STATUS_URL:', STATUS_URL, '(port:', statusPort, ')');

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        function updateStatus(data) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');

            if (data.error) {
                indicator.className = 'context-status-indicator error';
                statusText.textContent = 'Error';
                return;
            }

            // Update model
            const modelEl = document.getElementById('model-name');
            if (modelEl) {
                modelEl.textContent = data.model || 'Sonnet';
            }

            // Check if Claude process is running
            if (data.connected === false) {
                indicator.className = 'context-status-indicator error';
                statusText.textContent = 'Not Running';
                updateContextPanel(data);
                return;
            }

            // Update indicator based on context usage
            if (data.context_used && data.context_max) {
                const usage = data.context_used / data.context_max;

                if (usage > 0.9) {
                    indicator.className = 'context-status-indicator error';
                    statusText.textContent = 'Context High';
                } else if (usage > 0.7) {
                    indicator.className = 'context-status-indicator warning';
                    statusText.textContent = 'Context Warning';
                } else {
                    indicator.className = 'context-status-indicator';
                    statusText.textContent = 'Connected';
                }
            } else {
                indicator.className = 'context-status-indicator';
                statusText.textContent = 'Connected';
            }

            // Update the context panel with all data
            updateContextPanel(data);
        }

        // Context Panel Update
        function updateContextPanel(data) {
            const usageFill = document.getElementById('context-usage-fill');
            const usagePct = document.getElementById('context-usage-pct');
            const usageDetail = document.getElementById('context-usage-detail');

            // Context window may not be available (data is server-side in newer Claude Code)
            const contextMax = data.context_max || 200000;
            if (data.context_used && contextMax) {
                const pct = Math.min(100, (data.context_used / contextMax) * 100);
                usageFill.style.width = pct + '%';
                usagePct.textContent = pct.toFixed(1) + '%';
                usageDetail.textContent = formatNumber(data.context_used) + ' / ' + formatNumber(contextMax) + ' tokens';

                usageFill.classList.remove('warning', 'error');
                if (pct > 90) {
                    usageFill.classList.add('error');
                } else if (pct > 70) {
                    usageFill.classList.add('warning');
                }
            } else {
                // No context data available - show as N/A
                usageFill.style.width = '0%';
                usagePct.textContent = '-';
                usageDetail.textContent = 'Data not available locally';
                usageFill.classList.remove('warning', 'error');
                // Show the info note
                const infoNote = document.getElementById('context-info-note');
                if (infoNote) infoNote.style.display = 'block';
            }

            // Update stats - show dash for unavailable data (handle 0 as valid)
            document.getElementById('ctx-tokens-in').textContent = data.tokens_in != null ? formatNumber(data.tokens_in) : '-';
            document.getElementById('ctx-tokens-out').textContent = data.tokens_out != null ? formatNumber(data.tokens_out) : '-';
            document.getElementById('ctx-cache-read').textContent = data.cache_read != null ? formatNumber(data.cache_read) : '-';
            document.getElementById('ctx-cache-create').textContent = data.cache_creation != null ? formatNumber(data.cache_creation) : '-';
            document.getElementById('ctx-messages').textContent = data.message_count != null ? data.message_count : '-';
            document.getElementById('ctx-turns').textContent = data.turn_count != null ? data.turn_count : '-';
            document.getElementById('ctx-cost').textContent = data.cost != null ? '$' + data.cost.toFixed(2) : '-';

            // Update tool usage
            const toolList = document.getElementById('tool-usage-list');
            if (data.tool_uses && Object.keys(data.tool_uses).length > 0) {
                toolList.innerHTML = Object.entries(data.tool_uses)
                    .sort((a, b) => b[1] - a[1])
                    .map(([name, count]) => `
                        <div class="context-tool-item">
                            <span class="context-tool-name">${escapeHtml(name)}</span>
                            <span class="context-tool-count">${count}</span>
                        </div>
                    `).join('');
            } else {
                toolList.innerHTML = '<div class="context-empty">No tools used yet</div>';
            }

            // Update files list
            const fileList = document.getElementById('context-file-list');
            if (data.files_in_context && data.files_in_context.length > 0) {
                fileList.innerHTML = data.files_in_context
                    .map(file => {
                        const shortPath = file.split('/').slice(-2).join('/');
                        return `
                            <li class="context-file-item">
                                <span class="context-file-name" title="${escapeHtml(file)}">${escapeHtml(shortPath)}</span>
                            </li>
                        `;
                    }).join('');
            } else {
                fileList.innerHTML = '<li class="context-empty">No files detected</li>';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function pollStatus() {
            try {
                // Use detailed endpoint for more data
                const detailedUrl = STATUS_URL.replace('/status', '/status/detailed');
                console.log('Polling:', detailedUrl);
                const response = await fetch(detailedUrl);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Status data:', data);
                    updateStatus(data);
                } else {
                    console.warn('Status response not ok:', response.status);
                }
            } catch (e) {
                console.warn('Detailed fetch failed:', e.message);
                // Fallback to basic status
                try {
                    const response = await fetch(STATUS_URL);
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Basic status data:', data);
                        updateStatus(data);
                    }
                } catch (e2) {
                    console.warn('Basic fetch failed:', e2.message);
                    // Show error state
                    updateStatus({ error: true, connected: false });
                }
            }
        }

        // Poll every 5 seconds - URL is now calculated dynamically
        console.log('Starting status polling to:', STATUS_URL);
        pollStatus();
        setInterval(pollStatus, 5000);

        // =============================================
        // User Tracking & Heartbeat
        // =============================================
        (function() {
            const userBadge = document.getElementById('user-badge');
            const userName = document.getElementById('user-name');
            const usersOnline = document.getElementById('users-online');
            const usersCount = document.getElementById('users-count');
            const usersTooltip = document.getElementById('users-tooltip');

            let currentUser = null;
            let activeUsers = [];

            // Fetch current user info
            async function fetchUserInfo() {
                try {
                    const userUrl = STATUS_URL.replace('/status', '/status/user');
                    const response = await fetch(userUrl);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.authenticated && data.user) {
                            currentUser = data.user;
                            userName.textContent = data.user.display_name;
                            userBadge.classList.add('visible');

                            // Store short_id for potential future use
                            try {
                                localStorage.setItem('frank-user-short-id', data.user.short_id);
                            } catch (e) {}
                        }
                    }
                } catch (e) {
                    console.warn('Failed to fetch user info:', e);
                }
            }

            // Send heartbeat to keep user active
            async function sendHeartbeat() {
                try {
                    const heartbeatUrl = STATUS_URL.replace('/status', '/status/heartbeat');
                    const response = await fetch(heartbeatUrl, { method: 'POST' });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Heartbeat sent, active users:', data.active_users);
                    }
                } catch (e) {
                    console.warn('Heartbeat failed:', e);
                }
            }

            // Fetch list of active users
            async function fetchActiveUsers() {
                try {
                    const usersUrl = STATUS_URL.replace('/status', '/status/users');
                    const response = await fetch(usersUrl);
                    if (response.ok) {
                        const data = await response.json();
                        activeUsers = data.users || [];
                        const count = data.count || 0;

                        usersCount.textContent = count;
                        if (count > 0) {
                            usersOnline.classList.add('visible');
                        } else {
                            usersOnline.classList.remove('visible');
                        }

                        // Update tooltip content
                        if (activeUsers.length > 0) {
                            usersTooltip.innerHTML = activeUsers.map(u =>
                                '<div class="users-tooltip-item">' +
                                '<span class="user-dot"></span>' +
                                '<span>' + escapeHtml(u.display_name) + '</span>' +
                                '</div>'
                            ).join('');
                        } else {
                            usersTooltip.innerHTML = '<div class="users-tooltip-item">No active users</div>';
                        }
                    }
                } catch (e) {
                    console.warn('Failed to fetch active users:', e);
                }
            }

            // Toggle users tooltip on click
            usersOnline.addEventListener('click', (e) => {
                e.stopPropagation();
                usersTooltip.classList.toggle('visible');
            });

            // Close tooltip when clicking outside
            document.addEventListener('click', () => {
                usersTooltip.classList.remove('visible');
            });

            // Initialize user tracking
            fetchUserInfo();
            fetchActiveUsers();

            // Heartbeat every 60 seconds
            setInterval(sendHeartbeat, 60000);

            // Refresh active users every 30 seconds
            setInterval(fetchActiveUsers, 30000);

            // Send initial heartbeat after a short delay
            setTimeout(sendHeartbeat, 2000);
        })();

        // Version polling for update detection
        const updateIndicator = document.getElementById('update-indicator');
        const updateVersion = document.getElementById('update-version');
        const restartBtn = document.getElementById('restart-btn');

        async function checkForUpdates() {
            try {
                const versionUrl = STATUS_URL.replace('/status', '/status/version');
                const response = await fetch(versionUrl);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Version data:', data);

                    if (data.update_available) {
                        updateIndicator.classList.add('visible');
                        updateVersion.textContent = `v${data.current_revision}  v${data.latest_revision}`;
                    } else {
                        updateIndicator.classList.remove('visible');
                    }
                }
            } catch (e) {
                console.warn('Version check failed:', e.message);
            }
        }

        // Check for updates every 5 minutes
        checkForUpdates();
        setInterval(checkForUpdates, 5 * 60 * 1000);

        // Restart button handler
        restartBtn.addEventListener('click', async () => {
            if (!confirm('This will stop the current task and start a new one with the latest version.\n\nAny unsaved work will be preserved on the shared filesystem, but your terminal session will be disconnected.\n\nContinue?')) {
                return;
            }

            restartBtn.disabled = true;
            restartBtn.textContent = 'Restarting...';

            try {
                // Get the profile name from the URL path
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                const profileName = pathParts[0] || '';

                if (!profileName) {
                    alert('Could not determine profile name for restart.');
                    restartBtn.disabled = false;
                    restartBtn.textContent = 'Restart';
                    return;
                }

                // Call the API to restart the profile
                const apiUrl = `${window.location.protocol}//${window.location.host}/api/profiles/${profileName}/restart`;
                const response = await fetch(apiUrl, { method: 'POST' });

                if (response.ok) {
                    alert('Profile is restarting. Please wait a moment and then refresh the page.');
                    // Optionally auto-refresh after a delay
                    setTimeout(() => {
                        window.location.reload();
                    }, 30000);
                } else {
                    const error = await response.text();
                    alert(`Failed to restart: ${error}`);
                    restartBtn.disabled = false;
                    restartBtn.textContent = 'Restart';
                }
            } catch (e) {
                alert(`Error: ${e.message}\n\nYou can manually restart using:\nfrank ecs stop ${window.location.pathname.split('/')[1]}\nfrank ecs start ${window.location.pathname.split('/')[1]}`);
                restartBtn.disabled = false;
                restartBtn.textContent = 'Restart';
            }
        });

        // Floating Prompt Bubble
        (function() {
            const fab = document.getElementById('prompt-fab');
            const bubble = document.getElementById('prompt-bubble');
            const textarea = document.getElementById('prompt-bubble-text');
            const sendBtn = document.getElementById('prompt-bubble-send');
            const timerSelect = document.getElementById('prompt-timer');

            let timerInterval = null;
            let countdownInterval = null;
            let timerRemainingSeconds = 0;
            let timerTotalSeconds = 0;
            let timerPromptText = '';

            function showToast(message) {
                const toast = document.getElementById('prompt-toast');
                toast.textContent = message;
                toast.classList.add('visible');
                setTimeout(() => toast.classList.remove('visible'), 2000);
            }

            function formatCountdown(seconds) {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return m + ':' + String(s).padStart(2, '0');
            }

            function stopTimer() {
                if (timerInterval) clearInterval(timerInterval);
                if (countdownInterval) clearInterval(countdownInterval);
                timerInterval = null;
                countdownInterval = null;
                timerRemainingSeconds = 0;
                timerTotalSeconds = 0;
                timerPromptText = '';
                sendBtn.textContent = 'Send';
                sendBtn.classList.remove('stop');
                fab.classList.remove('timer-active');
                timerSelect.disabled = false;
            }

            function startCountdown() {
                timerRemainingSeconds = timerTotalSeconds;
                if (countdownInterval) clearInterval(countdownInterval);
                countdownInterval = setInterval(() => {
                    timerRemainingSeconds--;
                    if (timerRemainingSeconds <= 0) {
                        timerRemainingSeconds = timerTotalSeconds;
                    }
                    sendBtn.textContent = 'Stop (' + formatCountdown(timerRemainingSeconds) + ')';
                }, 1000);
            }

            async function doSend(text) {
                const autoSubmit = document.getElementById('prompt-auto-submit').checked;
                try {
                    const sendUrl = STATUS_URL.replace('/status', '/status/send-prompt');
                    const response = await fetch(sendUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, autoSubmit, session: 'frank-claude' }),
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            return true;
                        } else {
                            showToast('Failed: ' + (data.message || data.error || 'Unknown error'));
                        }
                    } else {
                        showToast('Failed: HTTP ' + response.status);
                    }
                } catch (e) {
                    console.error('Send failed:', e);
                    showToast('Network error: ' + e.message);
                }
                return false;
            }

            fab.addEventListener('click', () => {
                const isOpen = bubble.classList.toggle('open');
                fab.textContent = isOpen ? '\u00D7' : '+';
                if (isOpen) textarea.focus();
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && bubble.classList.contains('open')) {
                    bubble.classList.remove('open');
                    fab.textContent = timerInterval ? '+' : '+';
                }
            });

            async function sendPrompt() {
                // If timer is running, stop it
                if (timerInterval) {
                    stopTimer();
                    showToast('Timer stopped');
                    return;
                }

                const text = textarea.value.trim();
                if (!text) return;

                const interval = parseInt(timerSelect.value, 10);

                sendBtn.disabled = true;
                sendBtn.textContent = '...';

                const ok = await doSend(text);

                if (ok) {
                    const autoSubmit = document.getElementById('prompt-auto-submit').checked;
                    showToast(autoSubmit ? 'Sent to Claude!' : 'Pasted into Claude terminal');

                    if (interval > 0) {
                        // Start recurring timer
                        timerPromptText = text;
                        timerTotalSeconds = interval;
                        timerSelect.disabled = true;
                        fab.classList.add('timer-active');
                        sendBtn.classList.add('stop');
                        sendBtn.disabled = false;

                        startCountdown();

                        timerInterval = setInterval(async () => {
                            const sent = await doSend(timerPromptText);
                            if (sent) {
                                showToast('Timer: sent to Claude');
                            }
                        }, interval * 1000);

                        // Close bubble but keep timer running
                        bubble.classList.remove('open');
                        fab.textContent = '+';
                    } else {
                        textarea.value = '';
                        bubble.classList.remove('open');
                        fab.textContent = '+';
                        sendBtn.disabled = false;
                        sendBtn.textContent = 'Send';
                    }
                } else {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Send';
                }
            }

            sendBtn.addEventListener('click', sendPrompt);

            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    sendPrompt();
                }
            });
        })();

        // Mobile Tab Switching
        (function() {
            let isMobile = false;
            let currentMobileView = 'claude';

            function applyMobileView(view) {
                currentMobileView = view;
                const claudePane = document.querySelector('.pane.claude');
                const bashPane = document.querySelector('.pane.bash');
                const contextPanel = document.getElementById('context-panel');

                // Reset all
                claudePane.classList.remove('mobile-active');
                bashPane.classList.remove('mobile-active');
                contextPanel.classList.remove('mobile-visible');

                if (view === 'claude') {
                    claudePane.classList.add('mobile-active');
                } else if (view === 'bash') {
                    bashPane.classList.add('mobile-active');
                } else if (view === 'stats') {
                    contextPanel.classList.add('mobile-visible');
                }

                // Update tab bar active state
                document.querySelectorAll('#mobile-tab-bar button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.view === view);
                });
            }

            function handleResize() {
                const wasMobile = isMobile;
                isMobile = window.innerWidth <= 768;

                if (isMobile && !wasMobile) {
                    applyMobileView(currentMobileView);
                } else if (!isMobile && wasMobile) {
                    const claudePane = document.querySelector('.pane.claude');
                    const bashPane = document.querySelector('.pane.bash');
                    const contextPanel = document.getElementById('context-panel');

                    claudePane.classList.remove('mobile-active');
                    bashPane.classList.remove('mobile-active');
                    contextPanel.classList.remove('mobile-visible');
                }
            }

            // Wire tab clicks
            document.querySelectorAll('#mobile-tab-bar button').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyMobileView(btn.dataset.view);
                });
            });

            window.addEventListener('resize', handleResize);

            // Initial check
            handleResize();
        })();

        // Feedback handling
        const feedbackButtons = document.getElementById('feedback-buttons');
        const feedbackSent = document.getElementById('feedback-sent');

        document.querySelectorAll('.feedback-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const rating = btn.dataset.rating;
                const buttons = feedbackButtons.querySelectorAll('button');

                // Disable buttons
                buttons.forEach(b => b.disabled = true);

                try {
                    const feedbackUrl = STATUS_URL.replace('/status', '/status/feedback');
                    const response = await fetch(feedbackUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ rating }),
                    });

                    if (response.ok) {
                        // Show thank you message
                        feedbackButtons.style.display = 'none';
                        feedbackSent.style.display = 'block';

                        // Reset after 3 seconds
                        setTimeout(() => {
                            feedbackButtons.style.display = 'flex';
                            feedbackSent.style.display = 'none';
                            buttons.forEach(b => b.disabled = false);
                        }, 3000);
                    } else {
                        console.error('Feedback failed:', response.status);
                        buttons.forEach(b => b.disabled = false);
                    }
                } catch (e) {
                    console.error('Feedback error:', e);
                    buttons.forEach(b => b.disabled = false);
                }
            });
        });
        // =============================================
        // Loading Overlay - Neural Network Animation
        // =============================================
        (function() {
            const overlay = document.getElementById('loading-overlay');
            if (!overlay) return;

            const canvas = document.getElementById('loading-canvas');
            const ctx = canvas.getContext('2d');
            let animationId = null;

            // AI Trivia
            const trivia = [
                "GPT-3 has 175 billion parameters \u2014 roughly 1,000\u00d7 more than GPT-2.",
                "The term 'artificial intelligence' was coined at a Dartmouth workshop in 1956.",
                "Claude was named after Claude Shannon, the father of information theory.",
                "The first neural network, the Perceptron, was built in 1958 using physical hardware.",
                "A single Google search uses about the same energy as turning on a light for 17 seconds.",
                "The Turing Test was proposed by Alan Turing in 1950 to measure machine intelligence.",
                "Deep Blue defeated world chess champion Garry Kasparov in 1997.",
                "The ImageNet dataset that sparked the deep learning revolution contains 14 million images.",
                "AlphaGo defeated world Go champion Lee Sedol in 2016 with a move no human had ever played.",
                "The transformer architecture behind modern LLMs was introduced in the 2017 paper 'Attention Is All You Need'.",
                "ELIZA, created in 1966, was one of the first chatbots and mimicked a therapist.",
                "The human brain has roughly 86 billion neurons connected by 100 trillion synapses.",
                "Backpropagation, the algorithm that trains neural networks, was popularized in 1986.",
                "The word 'robot' comes from the Czech word 'robota', meaning forced labor.",
                "Geoffrey Hinton, Yann LeCun, and Yoshua Bengio are known as the 'Godfathers of Deep Learning'.",
                "GPUs were originally designed for gaming but became essential for training AI models.",
                "The MNIST handwritten digit dataset has been the 'Hello World' of machine learning since 1998.",
                "Reinforcement learning from human feedback (RLHF) helps align AI outputs with human preferences.",
                "The concept of 'attention' in transformers lets models focus on relevant parts of their input.",
                "Neural networks are loosely inspired by biological neurons but work very differently.",
                "Moore's Law predicted transistor density doubling every ~2 years, enabling modern AI hardware.",
                "The first AI winter lasted from 1974 to 1980 when funding dried up due to unmet expectations.",
                "Word2Vec showed that word relationships could be captured as vector arithmetic: king \u2212 man + woman \u2248 queen.",
                "Generative adversarial networks (GANs) use two competing neural networks to create realistic outputs.",
                "The bitter lesson by Rich Sutton: general methods leveraging computation beat specialized approaches.",
                "Claude Shannon's 1948 paper 'A Mathematical Theory of Communication' founded information theory.",
                "Tokenizers break text into subword pieces \u2014 'unhappiness' might become 'un', 'happiness'.",
                "The context window of an LLM determines how much text it can consider at once.",
                "Batch normalization, introduced in 2015, made training deep networks significantly easier.",
                "The term 'hallucination' in AI refers to confident but factually incorrect outputs."
            ];

            // Shuffle trivia
            for (let i = trivia.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [trivia[i], trivia[j]] = [trivia[j], trivia[i]];
            }

            let triviaIndex = 0;
            const triviaEl = document.getElementById('trivia-text');
            triviaEl.textContent = trivia[0];

            const triviaInterval = setInterval(() => {
                triviaEl.style.opacity = '0';
                setTimeout(() => {
                    triviaIndex = (triviaIndex + 1) % trivia.length;
                    triviaEl.textContent = trivia[triviaIndex];
                    triviaEl.style.opacity = '1';
                }, 400);
            }, 5000);

            // Canvas setup
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Particles / nodes
            const nodes = [];
            const nodeCount = Math.min(60, Math.floor(window.innerWidth * window.innerHeight / 15000));
            const connectionDist = 150;

            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    radius: Math.random() * 2 + 1,
                    pulse: Math.random() * Math.PI * 2,
                    pulseSpeed: Math.random() * 0.02 + 0.01
                });
            }

            function drawNetwork() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Update and draw connections
                for (let i = 0; i < nodes.length; i++) {
                    const a = nodes[i];
                    a.x += a.vx;
                    a.y += a.vy;
                    a.pulse += a.pulseSpeed;

                    // Wrap around edges
                    if (a.x < 0) a.x = canvas.width;
                    if (a.x > canvas.width) a.x = 0;
                    if (a.y < 0) a.y = canvas.height;
                    if (a.y > canvas.height) a.y = 0;

                    for (let j = i + 1; j < nodes.length; j++) {
                        const b = nodes[j];
                        const dx = a.x - b.x;
                        const dy = a.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < connectionDist) {
                            const alpha = (1 - dist / connectionDist) * 0.15;
                            ctx.beginPath();
                            ctx.moveTo(a.x, a.y);
                            ctx.lineTo(b.x, b.y);
                            ctx.strokeStyle = `rgba(124, 77, 255, ${alpha})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }

                // Draw nodes
                for (const node of nodes) {
                    const glow = Math.sin(node.pulse) * 0.3 + 0.7;
                    const r = node.radius * glow;

                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(79, 195, 247, ${glow * 0.6})`;
                    ctx.fill();

                    // Subtle outer glow
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r * 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(79, 195, 247, ${glow * 0.08})`;
                    ctx.fill();
                }

                animationId = requestAnimationFrame(drawNetwork);
            }

            drawNetwork();

            // Progress tracking
            const steps = ['step-workspace', 'step-plugins', 'step-terminals', 'step-ready'];
            let currentStep = 0;

            function setStep(index) {
                for (let i = 0; i < steps.length; i++) {
                    const el = document.getElementById(steps[i]);
                    el.classList.remove('active', 'done');
                    if (i < index) el.classList.add('done');
                    else if (i === index) el.classList.add('active');
                }
                currentStep = index;
            }

            // Readiness detection: poll status + check terminal iframes
            let terminalsReady = false;
            let statusReady = false;

            async function checkDetailedStatus() {
                try {
                    const detailedUrl = STATUS_URL.replace('/status', '/status/detailed');
                    const response = await fetch(detailedUrl, { signal: AbortSignal.timeout(3000) });
                    if (response.ok) {
                        const data = await response.json();
                        // Status server is responding
                        if (currentStep < 1) setStep(1);

                        // Check if Claude process is connected
                        if (data.connected !== false) {
                            statusReady = true;
                            if (currentStep < 2) setStep(2);
                        }
                        return data;
                    }
                } catch (e) {
                    // Status not ready yet
                }
                return null;
            }

            async function checkTerminals() {
                const claudeFrame = document.getElementById('claude-frame');
                const bashFrame = document.getElementById('bash-frame');

                try {
                    // Try fetching the terminal URLs to see if they respond
                    const results = await Promise.allSettled([
                        fetch(claudeFrame.src, { mode: 'no-cors', signal: AbortSignal.timeout(3000) }),
                        fetch(bashFrame.src, { mode: 'no-cors', signal: AbortSignal.timeout(3000) })
                    ]);

                    // With no-cors, a successful response (even opaque) means the server is up
                    const allOk = results.every(r => r.status === 'fulfilled');
                    if (allOk) {
                        terminalsReady = true;
                    }
                } catch (e) {
                    // Terminals not ready
                }
            }

            function dismissOverlay() {
                clearInterval(triviaInterval);
                clearInterval(readinessInterval);

                setStep(3); // "Almost ready..." -> done
                setTimeout(() => {
                    // Mark final step done
                    document.getElementById(steps[3]).classList.remove('active');
                    document.getElementById(steps[3]).classList.add('done');

                    setTimeout(() => {
                        overlay.classList.add('fade-out');
                        setTimeout(() => {
                            overlay.remove();
                            if (animationId) cancelAnimationFrame(animationId);
                            window.removeEventListener('resize', resizeCanvas);
                        }, 500);
                    }, 300);
                }, 400);
            }

            const readinessInterval = setInterval(async () => {
                await checkDetailedStatus();
                await checkTerminals();

                if (statusReady && terminalsReady) {
                    dismissOverlay();
                }
            }, 2000);

            // Initial check
            checkDetailedStatus();
            checkTerminals();
        })();
    </script>
</body>
</html>
